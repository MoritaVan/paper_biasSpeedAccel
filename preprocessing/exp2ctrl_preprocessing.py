#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan  2 12:22:01 2020

@author: Vanessa Morita


Preprocessing steps

Creates the following files:
subXX_BA_posFilter.h5      - data generated by ANEMO
subXX_BA_rawData.h5        - raw data for position, velocity and saccades
subXX_BA_qualityControl.h5 - list of trials with labels for bad data and bad fit

"""
#%%
import os
import sys
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

sys.path.append('./')
from functions.utils import *

os.chdir("../ANEMO") 
from ANEMO import ANEMO, read_edf

main_dir = "../data/biasAccelerationControl"
os.chdir(main_dir) # pc lab


import warnings
warnings.filterwarnings("ignore")
import traceback



#%% ANEMO parameters
screen_width_px  = 1920 # px
screen_height_px = 1080 # px
screen_width_cm  = 70   # cm
viewingDistance  = 57.  # cm

tan              = np.arctan((screen_width_cm/2)/viewingDistance)
screen_width_deg = 2. * tan * 180/np.pi
px_per_deg       = screen_width_px / screen_width_deg

param_exp = {# Mandatory :
                # - number of trials per block :
                      'N_trials' : 1,
                # - number of blocks :
                      'N_blocks' : 1,
                # - direction of the target :
                    # list of lists for each block containing the direction of
                    # the target for each trial is to -1 for left 1 for right
                      'dir_target' : [[],[]], # will be defined in the main loop
                # - number of px per degree for the experiment :
                      'px_per_deg' : px_per_deg,
                      'screen_width': screen_width_px,
                      'screen_height': screen_height_px,
             # OPTIONAL :
                # - subject name :
                      #'observer' : 's',
                # - list of the names of the events of the trial :
                      'list_events' : ['FixOn\n','FixOff\n',
                                      'TargetOn\n', 'TargetOff\n'],

              }


subjects   = ['sub-01', 'sub-02', 'sub-03', 'sub-04', 'sub-05']
conditions =   [
                'Va-100_V0-0', 
                'Vd-100_V0-0',
                'V1-100_V0-0', 
                'V2-100_V0-0',
                'V3-100_V0-0',
                'Va-75_Vd-25',
                'Vd-75_Va-25',
                ]


time_sup = 20 # time window to cut at the end of the trial

sacc_params = {}
# default:
#     'mindur': 5,
#     'maxdur': 100,
#     'minsep': 30,
#     'before_sacc': 5,
#     'after_sacc': 15

sacc_params = {
    1: {
        'mindur': 5,
        'maxdur': 150,
        'minsep': 30,
        'before_sacc': 20,
        'after_sacc': 20
        },
    2: {
        'mindur': 5,
        'maxdur': 125,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 20
        },
    3: {
        'mindur': 5,
        'maxdur': 125,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 25
        },
    4: {
        'mindur': 5,
        'maxdur': 125,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 25
        },
    5: {
        'mindur': 5,
        'maxdur': 100,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 20
        },
    6: {
        'mindur': 5,
        'maxdur': 125,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 20
        },
    7: {
        'mindur': 5,
        'maxdur': 125,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 25
        },
    8: {
        'mindur': 5,
        'maxdur': 125,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 20
        },
    9: {
        'mindur': 5,
        'maxdur': 125,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 25
        },
    10: {
        'mindur': 5,
        'maxdur': 125,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 25
        },
    11: {
        'mindur': 5,
        'maxdur': 125,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 20
        },
    12: {
        'mindur': 5,
        'maxdur': 125,
        'minsep': 30,
        'before_sacc': 15,
        'after_sacc': 20
        },
    }

t  = np.linspace(0,0.6,600)
v1 = 11*np.ones(len(t))
v2 = 22*np.ones(len(t))
v3 = 33*np.ones(len(t))
va = 11 + 22*t
vd = 33 - 22*t

velocities = {
    'V1': {
        't': t,
        'v': v1,
    },
    'V2': {
        't': t,
        'v': v2,
    },
    'V3': {
        't': t,
        'v': v3,
    },
    'Va': {
        't': t,
        'v': va,
    },
    'Vd': {
        't': t,
        'v': vd,
    },
}

#%%

showPlots   = 0 
manualCheck = 0

# equation = 'linear'
equation = 'nonlinear'
# equation = 'sigmoid'
print('\n\t\tEquation:\t',equation.upper(),'\n')

for idxSub, sub in enumerate(subjects):
    idxSub = idxSub + 1
    print('Subject:',sub)

    for cond in conditions:
        outputFolder_plots = '{sub}/plots/'.format(sub=sub)
        
        try :
            dataFile   = '{main_dir}/raw/{sub}/{sub}_{cond}_eyeData.asc'.format(main_dir=".",sub=sub, cond=cond) # VANESSA lab
            tgDirFile  = '{main_dir}/raw/{sub}/{sub}_{cond}_events.tsv'.format(main_dir=".", sub=sub, cond=cond) # VANESSA lab
                
            if equation=='nonlinear':
                h5_file = '{sub}/{sub}_{cond}_posFilter_nonlinear.h5'.format(sub=sub, cond=cond) 
                h5_rawfile = '{sub}/{sub}_{cond}_rawData_nonlinear.h5'.format(sub=sub, cond=cond)
                h5_qcfile = '{sub}/{sub}_{cond}_qualityControl_nonlinear.h5'.format(sub=sub, cond=cond) 
                fitPDFFile = '{plotFolder}{sub}_{cond}_fit_nonlinear.pdf'.format(plotFolder=outputFolder_plots, sub=sub, cond=cond)
                badFitsFile = '{}/qc/{}_{}_badFits_nonlinear.pdf'.format(outputFolder_plots, sub, cond)   

            elif equation=='sigmoid':
                h5_file = '{sub}/{sub}_{cond}_posFilter_lin-sigmo.h5'.format(sub=sub, cond=cond) 
                h5_rawfile = '{sub}/{sub}_{cond}_rawData_lin-sigmo.h5'.format(sub=sub, cond=cond)
                h5_qcfile = '{sub}/{sub}_{cond}_qualityControl_lin-sigmo.h5'.format(sub=sub, cond=cond)
                fitPDFFile = '{plotFolder}{sub}_{cond}_fit_lin-sigmo.pdf'.format(plotFolder=outputFolder_plots, sub=sub, cond=cond)
                badFitsFile = '{}/qc/{}_{}_badFits_lin-sigmo.pdf'.format(outputFolder_plots, sub, cond)   

                allow_baseline, allow_horizontalShift = True, True

            elif equation=='linear':    
                h5_file = '{sub}/{sub}_{cond}_posFilter_linear.h5'.format(sub=sub, cond=cond) 
                h5_rawfile = '{sub}/{sub}_{cond}_rawData_linear.h5'.format(sub=sub, cond=cond)
                h5_qcfile = '{sub}/{sub}_{cond}_qualityControl_linear.h5'.format(sub=sub, cond=cond)
                fitPDFFile = '{plotFolder}{sub}_{cond}_fit_linear.pdf'.format(plotFolder=outputFolder_plots, sub=sub, cond=cond)
                badFitsFile = '{}/qc/{}_{}_badFits_linear.pdf'.format(outputFolder_plots, sub, cond)   

                fit_steadyState = False

            paramsRaw   = pd.DataFrame()
            qualityCtrl = pd.DataFrame()
            paramsSub   = pd.DataFrame()

            # make figure folder
            try: os.makedirs(outputFolder_plots)
            except: pass
            # make figure folder
            try: os.makedirs(''.join([outputFolder_plots,'qc/']))
            except: pass

            # for diagnostic purposes:
            badTrialsFile  = '{}/qc/{}_{}_badTrials.pdf'.format(outputFolder_plots, sub, cond)

            badTrialspdf   = PdfPages(badTrialsFile)
            badFitspdf      = PdfPages(badFitsFile)

            pdf = PdfPages(fitPDFFile) # opens the pdf file to save the figures

            data   = read_edf(dataFile, start='FixOff', stop='TargetOff')
            tg_dir = pd.read_csv(tgDirFile, sep='\t')['eyemov_direction']
            tg_vel = pd.read_csv(tgDirFile, sep='\t')['trial_velocity']
            
            vels = cond.split('_')
            vel0 = vels[0][:2]
            vel1 = vels[1][:2]
            tg_vel = [vel0 if x==0 else vel1 for x in tg_vel]

            # change directions from 0/1 diagonals to -1/1
            param_exp['dir_target'][1] = [1 if (item == 1) | (item==4) else -1 for item in tg_dir]
            param_exp['dir_target'][0] = [1 if (item == 1) | (item==2) else -1 for item in tg_dir]
            
            param_exp['N_trials'] = len(data)

            # creates an ANEMO instance
            A   = ANEMO(param_exp)
            Fit = A.Fit(param_exp)
            
            firstTrial = True

            for trial in list(range(param_exp['N_trials'])):
                print('Trial {0}, cond {1}, sub {2}'.format(trial, cond,sub))
                
                if len(data[trial]['x']) and len(data[trial]['y']):
                    
                    data[trial]['y'] = screen_height_px-data[trial]['y']

                    type_v = 'U' if param_exp['dir_target'][0][trial] == 1 else 'D'
                    type_h = 'R' if param_exp['dir_target'][1][trial] == 1 else 'L'
                        
                    trialType_txt = '{v}{h}'.format(v=type_v,h=type_h)


                    # get trial data and transform into the arg
                    arg = A.arg(data_trial = data[trial], trial = trial, block = 0)

                    TargetOn_0 = arg.TargetOn-arg.t_0
                    
                    pos_deg_x = A.data_deg(data         = arg.data_x,
                                            StimulusOf  = arg.StimulusOf,
                                            t_0         = arg.t_0,
                                            saccades    = arg.saccades,
                                            before_sacc = sacc_params[idxSub]['before_sacc'],
                                            after_sacc  = sacc_params[idxSub]['after_sacc'],
                                            filt=None, cutoff=30, sample_rate=1000)
                    
                    pos_deg_y = A.data_deg(data         = arg.data_y,
                                            StimulusOf  = arg.StimulusOf,
                                            t_0         = arg.t_0,
                                            saccades    = arg.saccades,
                                            before_sacc = sacc_params[idxSub]['before_sacc'],
                                            after_sacc  = sacc_params[idxSub]['after_sacc'],
                                            filt=None, cutoff=30, sample_rate=1000)
                    
                    velocity_deg_x = A.velocity(data = pos_deg_x,
                                        filter_before = True, filter_after = False, cutoff = 30, sample_rate = 1000)

                    velocity_deg_y = A.velocity(data = pos_deg_y,
                                        filter_before = True, filter_after = False, cutoff = 30, sample_rate = 1000)
                    
                    misac = A.detec_misac(velocity_x = velocity_deg_x,
                                        velocity_y = velocity_deg_y,
                                        t_0        = arg.t_0,
                                        VFAC       = 5,
                                        mindur     = sacc_params[idxSub]['mindur'],
                                        maxdur     = sacc_params[idxSub]['maxdur'],
                                        minsep     = sacc_params[idxSub]['minsep'])

                    new_saccades = arg.saccades
                    [sacc.extend([0,0,0,0,0]) for sacc in misac] # transform misac into the eyelink format
                    new_saccades.extend(misac)
                    # new_saccades = [x[:2] for x in new_saccades]
                    
                    sac = A.detec_sac(velocity_x = velocity_deg_x,
                                        velocity_y = velocity_deg_y,
                                        t_0        = arg.t_0,
                                        VFAC       = 5,
                                        mindur     = sacc_params[idxSub]['mindur'],
                                        maxdur     = sacc_params[idxSub]['maxdur'],
                                        minsep     = sacc_params[idxSub]['minsep'])
                    
                    [sacc.extend([0,0,0,0,0]) for sacc in sac] # transform misac into the eyelink format
                    new_saccades.extend(sac)

                    blinks = data[trial]['events']['Eblk'].copy()
                    if len(data[trial]['events']['Sblk']) >  len(data[trial]['events']['Eblk']):
                        blinks.append(list([data[trial]['events']['Sblk'][-1], data[trial]['trackertime'][-1]]))
                    blinks = [x[:2] for x in blinks]
                    
                    velocity_x_NAN = A.data_NAN(data = velocity_deg_x,
                                    saccades          = new_saccades,
                                    trackertime       = arg.trackertime,
                                    before_sacc       = sacc_params[idxSub]['before_sacc'],
                                    after_sacc        = sacc_params[idxSub]['after_sacc'])
                    
                    velocity_y_NAN = A.data_NAN(data = velocity_deg_y,
                                    saccades          = new_saccades,
                                    trackertime       = arg.trackertime,
                                    before_sacc       = sacc_params[idxSub]['before_sacc'],
                                    after_sacc        = sacc_params[idxSub]['after_sacc'])

                    time = arg.trackertime-arg.TargetOn

                    idx2keep_y = np.logical_and(time>=-300, time<1000)
                    time_y  = time[idx2keep_y]
                    pos_y = arg.data_y[idx2keep_y]
                    vel_y = velocity_y_NAN[idx2keep_y]
                    
                    idx2keep_x = np.logical_and(time>=-300, time<1000)
                    time_x  = time[idx2keep_x]
                    pos_x = arg.data_x[idx2keep_x]
                    vel_x = velocity_x_NAN[idx2keep_x]
                    
                    vel_x[:25]  = np.nan
                    vel_y[:25]  = np.nan
                    vel_x[-25:] = np.nan
                    vel_y[-25:] = np.nan
                    
                    pos_deg_x = pos_deg_x[idx2keep_x]
                    pos_deg_y = pos_deg_y[idx2keep_y]

                    # calc saccades relative to t_0
                    # because I am passing the time relative to t_0 to ANEMO            
                    for sacc in new_saccades:
                        sacc[0] = sacc[0] - arg.TargetOn
                        sacc[1] = sacc[1] - arg.TargetOn
                    
                    sDict = {
                        'condition': cond,
                        'trial': trial,
                        'direction': trialType_txt,
                        'time_x': time_x,
                        'time_y': time_y,
                        'posPxl_x': pos_x,
                        'posPxl_y': pos_y,
                        'posDeg_x': pos_deg_x,
                        'posDeg_y': pos_deg_y,
                        'velocity_x': vel_x,
                        'velocity_y': vel_y,
                        'saccades': new_saccades
                    }

                    # save trial data to a dataframe
                    paramsRaw = pd.concat([paramsRaw, pd.DataFrame([sDict], columns=sDict.keys())], ignore_index = True)

                    # test: if bad trial
                    if (np.mean(np.isnan(velocity_x_NAN[TargetOn_0-100:TargetOn_0+100])) > .7 or
                        np.mean(np.isnan(velocity_x_NAN[:-time_sup])) > .6 or
                        longestNanRun(velocity_x_NAN[TargetOn_0-150:TargetOn_0+600]) > 200):

                        print('Skipping bad trial...')

                        plt.clf()
                        fig = plt.figure(figsize=(10, 4))
                        plt.suptitle('Trial %d' % trial)
                        plt.subplot(1,2,1)
                        plt.plot(velocity_x_NAN[:-time_sup])
                        plt.axvline(x = 200, linewidth = 1, linestyle = '--', color = 'k')
                        plt.axvline(x = 800, linewidth = 1, linestyle = '--', color = 'k')
                        plt.xlim(-100,600)
                        plt.ylim(-15,15)
                        plt.xlabel('Time (ms)')
                        plt.ylabel('Velocity - x axis')
                        plt.subplot(1,2,2)
                        plt.plot(velocity_y_NAN[:-time_sup])
                        plt.axvline(x = 200, linewidth = 1, linestyle = '--', color = 'k')
                        plt.axvline(x = 800, linewidth = 1, linestyle = '--', color = 'k')
                        plt.xlim(-100,600)
                        plt.ylim(-35,35)
                        plt.xlabel('Time (ms)')
                        plt.ylabel('Velocity - y axis')

                        reason = ''
                        if ((np.mean(np.isnan(velocity_x_NAN[TargetOn_0-100:TargetOn_0+100])) > .7)):
                            print('too many NaNs around the start of the pursuit')
                            reason = reason + ' >.70 of NaNs around the start of the pursuit'
                            badTrialspdf.savefig(fig)
                        if np.mean(np.isnan(velocity_x_NAN[:-time_sup])) > .6:
                            print('too many NaNs overall')
                            reason = reason + ' >{0} of NaNs overall'.format(.6)
                            badTrialspdf.savefig(fig)
                        if longestNanRun(velocity_x_NAN[TargetOn_0-150:TargetOn_0+600]) > 200:
                            print('at least one nan sequence with more than 200ms')
                            reason = reason + ' At least one nan sequence with more than 200ms'
                            badTrialspdf.savefig(fig)


                        newResult = dict()
                        newResult['condition']  = cond
                        newResult['trial']      = trial
                        newResult['target_dir'] = trialType_txt
                        
                        x = arg.trackertime-arg.TargetOn
                        newResult['time']                                        = x[:-time_sup]
                        newResult['velocity_x'], newResult['velocity_y']         = velocity_x_NAN[:-time_sup], velocity_y_NAN[:-time_sup]
                        newResult['saccades']                                    = np.array(new_saccades)

                        qCtrl = dict()
                        qCtrl['sub']            = sub
                        qCtrl['condition']      = cond
                        qCtrl['trial']          = trial
                        qCtrl['keep_trial']     = 0
                        qCtrl['good_fit']       = 0
                        qCtrl['discard_reason'] = reason

                    else: # if not a bad trial, does the fit
                        
                        # max_time = velocities[tg_vel[trial]]['t'][-1]*1000 if equation=='sigmoid' else 300
                        max_time = 300

                        vel_x = vel_x[time_x <= max_time]
                        vel_y = vel_y[time_y <= max_time]
                        pos_x = pos_x[time_x <= max_time]
                        pos_y = pos_y[time_y <= max_time]
                        time_x = time_x[time_x <= max_time]
                        time_y = time_y[time_y <= max_time]

                        classic_lat_x, classic_max_x, classic_ant_x = A.classical_method.Full(vel_x, 300)
                        # print('classical latency: {:+.2f}, max: {:+.2f}, anti: {:+.2f}'.format(classic_lat_x, classic_max_x, classic_ant_x))
                        classic_ant_x = classic_ant_x if not np.isnan(classic_ant_x) else 0.5

                        classic_lat_y, classic_max_y, classic_ant_y = A.classical_method.Full(vel_y, 300)
                        # print('classical latency: {:+.2f}, max: {:+.2f}, anti: {:+.2f}'.format(classic_lat_y, classic_max_y, classic_ant_y))
                        classic_ant_y = classic_ant_y if not np.isnan(classic_ant_y) else 0.5 # acceleration threshold, to avoid local minima when doing the fit
                        
                        if equation=='linear':
                            param_fit_x, inde_var_x = Fit.generation_param_fit(equation = 'fct_velocity_line',
                                                                dir_target    = param_exp['dir_target'][1][trial],
                                                                trackertime   = time_x,
                                                                TargetOn      = 0,
                                                                StimulusOf    = time_x[0],
                                                                saccades      = new_saccades,
                                                                value_latency = classic_lat_x,
                                                                value_maxi    = classic_max_x,
                                                                value_anti    = classic_ant_x*5)
                            param_fit_y, inde_var_y = Fit.generation_param_fit(equation = 'fct_velocity_line',
                                                                dir_target    = param_exp['dir_target'][0][trial],
                                                                trackertime   = time_y,
                                                                TargetOn      = 0,
                                                                StimulusOf    = time_y[0],
                                                                saccades      = new_saccades,
                                                                value_latency = classic_lat_y,
                                                                value_maxi    = classic_max_y,
                                                                value_anti    = classic_ant_y*5)
                            
                            result_x = Fit.Fit_trial(vel_x,
                                                    equation      = 'fct_velocity_line',
                                                    data_x        = pos_x,
                                                    dir_target    = param_exp['dir_target'][1][trial],
                                                    trackertime   = list(inde_var_x['x']),
                                                    TargetOn      = 0,
                                                    StimulusOf    = time_x[0],
                                                    saccades      = new_saccades,
                                                    time_sup      = None,
                                                    step_fit      = 2,
                                                    param_fit     = param_fit_x,
                                                    inde_vars     = inde_var_x,
                                                    value_latency = classic_lat_x,
                                                    value_steady_state = classic_max_x,
                                                    value_anti    = classic_ant_x*5,
                                                    fit_steadyState = fit_steadyState,
                                                    )
                            result_y = Fit.Fit_trial(vel_y,
                                                    equation      = 'fct_velocity_line',
                                                    data_x        = pos_y,
                                                    dir_target    = param_exp['dir_target'][0][trial],
                                                    trackertime   = list(inde_var_y['x']),
                                                    TargetOn      = 0,
                                                    StimulusOf    = time_y[0],
                                                    saccades      = new_saccades,
                                                    time_sup      = None,
                                                    step_fit      = 2,
                                                    param_fit     = param_fit_y,
                                                    inde_vars     = inde_var_y,
                                                    value_latency = classic_lat_y,
                                                    value_steady_state = classic_max_y,
                                                    value_anti    = classic_ant_y*5,
                                                    fit_steadyState = fit_steadyState,
                                                    )

                            eq_x = ANEMO.Equation.fct_velocity_line(inde_var_x['x'],
                                                        result_x.params['t_0'],
                                                        result_x.params['t_end'],
                                                        result_x.params['dir_target'],
                                                        result_x.params['baseline'],
                                                        result_x.params['start_anti'],
                                                        result_x.params['a_anti'],
                                                        result_x.params['latency'],
                                                        result_x.params['ramp_pursuit'],
                                                        result_x.params['steady_state'],
                                                        fit_steadyState = fit_steadyState)
                            eq_y = ANEMO.Equation.fct_velocity_line(inde_var_y['x'],
                                                        result_y.params['t_0'],
                                                        result_y.params['t_end'],
                                                        result_y.params['dir_target'],
                                                        result_y.params['baseline'],
                                                        result_y.params['start_anti'],
                                                        result_y.params['a_anti'],
                                                        result_y.params['latency'],
                                                        result_y.params['ramp_pursuit'],
                                                        result_y.params['steady_state'],
                                                        fit_steadyState = fit_steadyState)
                        elif equation=='nonlinear':
                            param_fit_x, inde_var_x = Fit.generation_param_fit(equation = 'fct_velocity_antiSigmo',
                                                                dir_target    = param_exp['dir_target'][1][trial],
                                                                trackertime   = time_x,
                                                                TargetOn      = 0,
                                                                StimulusOf    = time_x[0],
                                                                saccades      = new_saccades,
                                                                value_latency = classic_lat_x,
                                                                value_maxi    = classic_max_x,
                                                                value_anti    = classic_ant_x*5)
                            param_fit_y, inde_var_y = Fit.generation_param_fit(equation = 'fct_velocity_antiSigmo',
                                                                dir_target    = param_exp['dir_target'][0][trial],
                                                                trackertime   = time_y,
                                                                TargetOn      = 0,
                                                                StimulusOf    = time_y[0],
                                                                saccades      = new_saccades,
                                                                value_latency = classic_lat_y,
                                                                value_maxi    = classic_max_y,
                                                                value_anti    = classic_ant_y*5)
                            
                            result_x = Fit.Fit_trial(vel_x,
                                                    equation      = 'fct_velocity_antiSigmo',
                                                    data_x        = pos_x,
                                                    dir_target    = param_exp['dir_target'][1][trial],
                                                    trackertime   = list(inde_var_x['x']),
                                                    TargetOn      = 0,
                                                    StimulusOf    = time_x[0],
                                                    saccades      = new_saccades,
                                                    time_sup      = None,
                                                    step_fit      = 2,
                                                    param_fit     = param_fit_x,
                                                    inde_vars     = inde_var_x,
                                                    value_latency = classic_lat_x,
                                                    value_steady_state = classic_max_x,
                                                    value_anti    = classic_ant_x*5,
                                                    allow_baseline = True,
                                                    )
                            result_y = Fit.Fit_trial(vel_y,
                                                    equation      = 'fct_velocity_antiSigmo',
                                                    data_x        = pos_y,
                                                    dir_target    = param_exp['dir_target'][0][trial],
                                                    trackertime   = list(inde_var_y['x']),
                                                    TargetOn      = 0,
                                                    StimulusOf    = time_y[0],
                                                    saccades      = new_saccades,
                                                    time_sup      = None,
                                                    step_fit      = 2,
                                                    param_fit     = param_fit_y,
                                                    inde_vars     = inde_var_y,
                                                    value_latency = classic_lat_y,
                                                    value_steady_state = classic_max_y,
                                                    value_anti    = classic_ant_y*5,
                                                    allow_baseline = True,
                                                    )

                            eq_x = ANEMO.Equation.fct_velocity_antiSigmo(
                                                x = inde_var_x['x'],
                                                t_0 = result_x.params['t_0'],
                                                t_end = result_x.params['t_end'],
                                                dir_target = result_x.params['dir_target'],
                                                baseline = result_x.params['baseline'],
                                                start_anti = result_x.params['start_anti'],
                                                a_anti = result_x.params['a_anti'],
                                                anti_offset = result_x.params['anti_offset'],
                                                ramp_pursuit = result_x.params['ramp_pursuit'],
                                                horizontal_shift = result_x.params['horizontal_shift'],
                                                steady_state = result_x.params['steady_state'],
                                                allow_baseline = result_x.params['allow_baseline'])
                            eq_y = ANEMO.Equation.fct_velocity_antiSigmo(
                                                x = inde_var_y['x'],
                                                t_0 = result_y.params['t_0'],
                                                t_end = result_y.params['t_end'],
                                                dir_target = result_y.params['dir_target'],
                                                baseline = result_y.params['baseline'],
                                                start_anti = result_y.params['start_anti'],
                                                a_anti = result_y.params['a_anti'],
                                                anti_offset = result_y.params['anti_offset'],
                                                ramp_pursuit = result_y.params['ramp_pursuit'],
                                                horizontal_shift = result_y.params['horizontal_shift'],
                                                steady_state = result_y.params['steady_state'],
                                                allow_baseline = result_y.params['allow_baseline'])
                        
                        elif equation=='sigmoid':
                            param_fit_x, inde_var_x = Fit.generation_param_fit(equation = 'fct_velocity_sigmo',
                                                                dir_target    = param_exp['dir_target'][1][trial],
                                                                trackertime   = time_x,
                                                                TargetOn      = 0,
                                                                StimulusOf    = time_x[0],
                                                                saccades      = new_saccades,
                                                                value_latency = classic_lat_x,
                                                                value_maxi    = classic_max_x,
                                                                value_anti    = classic_ant_x*5)
                            param_fit_y, inde_var_y = Fit.generation_param_fit(equation = 'fct_velocity_sigmo',
                                                                dir_target    = param_exp['dir_target'][0][trial],
                                                                trackertime   = time_y,
                                                                TargetOn      = 0,
                                                                StimulusOf    = time_y[0],
                                                                saccades      = new_saccades,
                                                                value_latency = classic_lat_y,
                                                                value_maxi    = classic_max_y,
                                                                value_anti    = classic_ant_y*5)
                            
                            result_x = Fit.Fit_trial(vel_x,
                                                    equation      = 'fct_velocity_sigmo',
                                                    data_x        = pos_x,
                                                    dir_target    = param_exp['dir_target'][1][trial],
                                                    trackertime   = list(inde_var_x['x']),
                                                    TargetOn      = 0,
                                                    StimulusOf    = time_x[0],
                                                    saccades      = new_saccades,
                                                    time_sup      = None,
                                                    step_fit      = 2,
                                                    param_fit     = param_fit_x,
                                                    inde_vars     = inde_var_x,
                                                    value_latency = classic_lat_x,
                                                    value_steady_state = classic_max_x,
                                                    value_anti    = classic_ant_x*5,
                                                    allow_baseline = True,
                                                    )
                            result_y = Fit.Fit_trial(vel_y,
                                                    equation      = 'fct_velocity_sigmo',
                                                    data_x        = pos_y,
                                                    dir_target    = param_exp['dir_target'][0][trial],
                                                    trackertime   = list(inde_var_y['x']),
                                                    TargetOn      = 0,
                                                    StimulusOf    = time_y[0],
                                                    saccades      = new_saccades,
                                                    time_sup      = None,
                                                    step_fit      = 2,
                                                    param_fit     = param_fit_y,
                                                    inde_vars     = inde_var_y,
                                                    value_latency = classic_lat_y,
                                                    value_steady_state = classic_max_y,
                                                    value_anti    = classic_ant_y*5,
                                                    allow_baseline = True,
                                                    )

                            eq_x = ANEMO.Equation.fct_velocity_sigmo(
                                                x = inde_var_x['x'],
                                                t_0 = result_x.params['t_0'],
                                                t_end = result_x.params['t_end'],
                                                dir_target = result_x.params['dir_target'],
                                                baseline = result_x.params['baseline'],
                                                start_anti = result_x.params['start_anti'],
                                                a_anti = result_x.params['a_anti'],
                                                latency = result_x.params['latency'],
                                                ramp_pursuit = result_x.params['ramp_pursuit'],
                                                horizontal_shift = result_x.params['horizontal_shift'],
                                                steady_state = result_x.params['steady_state'],
                                                allow_baseline = result_x.params['allow_baseline'],
                                                allow_horizontalShift = result_x.params['allow_horizontalShift'])
                            eq_y = ANEMO.Equation.fct_velocity_sigmo(
                                                x = inde_var_y['x'],
                                                t_0 = result_y.params['t_0'],
                                                t_end = result_y.params['t_end'],
                                                dir_target = result_y.params['dir_target'],
                                                baseline = result_y.params['baseline'],
                                                start_anti = result_y.params['start_anti'],
                                                a_anti = result_y.params['a_anti'],
                                                latency = result_y.params['latency'],
                                                ramp_pursuit = result_y.params['ramp_pursuit'],
                                                horizontal_shift = result_y.params['horizontal_shift'],
                                                steady_state = result_y.params['steady_state'],
                                                allow_baseline = result_y.params['allow_baseline'],
                                                allow_horizontalShift = result_y.params['allow_horizontalShift'])
                            
                            
                        newResult = dict()
                        newResult['condition']                                   = cond
                        newResult['trial']                                       = trial
                        newResult['target_dir']                                  = trialType_txt
                        newResult['trial_velocity']                              = tg_vel[trial]
                        newResult['time_x'], newResult['time_y']                 = time_x, time_y
                        newResult['velocity_x'], newResult['velocity_y']         = vel_x, vel_y
                        newResult['saccades']                                    = np.array(new_saccades)
                        newResult['t_0']                                         = result_x.params['t_0'].value
                        newResult['t_end']                                       = result_x.params['t_end'].value

                        newResult['dir_target_x'], newResult['dir_target_y']     = result_x.params['dir_target'].value, result_y.params['dir_target'].value
                        newResult['baseline_x'], newResult['baseline_y']         = result_x.params['baseline'].value, result_y.params['baseline'].value
                        newResult['aSPon_x'], newResult['aSPon_y']               = result_x.params['start_anti'].value, result_y.params['start_anti'].value
                        newResult['aSPv_slope_x'], newResult['aSPv_slope_y']     = result_x.params['a_anti'].value, result_y.params['a_anti'].value
                        newResult['SPacc_x'], newResult['SPacc_y']               = result_x.params['ramp_pursuit'].value, result_y.params['ramp_pursuit'].value
                        newResult['SPss_x'], newResult['SPss_y']                 = result_x.params['steady_state'].value, result_y.params['steady_state'].value
                        newResult['do_whitening_x'], newResult['do_whitening_y'] = result_x.params['do_whitening'].value, result_y.params['do_whitening'].value

                        if equation=='sigmoid':
                            newResult['aSPoff_x']         = np.round(result_x.params['latency'].value) 
                            newResult['aSPoff_y']         = np.round(result_y.params['latency'].value) 

                            _, idx_aSPoff = closest(time, newResult['aSPoff_x'])
                            vel_at_latency = eq_x[idx_aSPoff] + (newResult['SPss_x']-eq_x[idx_aSPoff])*0.05   
                            vel, idx = closest(eq_x[idx_aSPoff:], vel_at_latency)   

                            newResult['SPlat_x']          = time_x[idx+idx_aSPoff]
                            newResult['aSPv_x']           = eq_x[idx_aSPoff]
                            newResult['horiz_shift_x']    = result_x.params['horizontal_shift'].value 

                            _, idx_aSPoff = closest(time, newResult['aSPoff_y'])
                            vel_at_latency = eq_y[idx_aSPoff] + (newResult['SPss_y']-eq_y[idx_aSPoff])*0.05   
                            vel, idx = closest(eq_y[idx_aSPoff:], vel_at_latency)   

                            newResult['SPlat_y']          = time_y[idx+idx_aSPoff]
                            newResult['aSPv_y']           = eq_y[idx_aSPoff]
                            newResult['horiz_shift_y']    = result_y.params['horizontal_shift'].value 

                            newResult['horizontal_shift_x'] = result_x.params['horizontal_shift'].value
                            newResult['horizontal_shift_y'] = result_y.params['horizontal_shift'].value
                            newResult['allow_baseline'] = allow_baseline
                            newResult['allow_horizontalShift'] = allow_horizontalShift
                            
                        elif equation=='linear':
                            newResult['SPlat_x']          = np.round(result_x.params['latency'].value)
                            newResult['SPlat_y']          = np.round(result_y.params['latency'].value)

                            _, idx_latency = closest(time, newResult['SPlat_x'])
                            newResult['aSPv_x']           = eq_x[idx_latency]

                            _, idx_latency = closest(time, newResult['SPlat_y'])
                            newResult['aSPv_y']           = eq_y[idx_latency]

                            newResult['fit_steadyState'] = fit_steadyState

                        elif equation=='nonlinear':
                            newResult['aSPoff_x']         = np.round(result_x.params['anti_offset'].value)  
                            newResult['aSPoff_y']         = np.round(result_y.params['anti_offset'].value)  

                            _, idx_aSPoff = closest(time, newResult['aSPoff_x'])
                            vel_at_latency = eq_x[idx_aSPoff] + (newResult['SPss_x']-eq_x[idx_aSPoff])*0.05   
                            vel, idx = closest(eq_x[idx_aSPoff:], vel_at_latency)   

                            newResult['SPlat_x']          = time_x[idx+idx_aSPoff]
                            newResult['aSPv_x']           = eq_x[idx_aSPoff]
                            newResult['horiz_shift_x']    = result_x.params['horizontal_shift'].value 

                            _, idx_aSPoff = closest(time, newResult['aSPoff_y'])
                            vel_at_latency = eq_y[idx_aSPoff] + (newResult['SPss_y']-eq_y[idx_aSPoff])*0.05   
                            vel, idx = closest(eq_y[idx_aSPoff:], vel_at_latency)   

                            newResult['SPlat_y']          = time_y[idx+idx_aSPoff]
                            newResult['aSPv_y']           = eq_y[idx_aSPoff]
                            newResult['horiz_shift_y']    = result_y.params['horizontal_shift'].value 

                            newResult['allow_baseline'] = result_x.params['allow_baseline']
                            
                            
                        newResult['aic_x'], newResult['aic_y']                   = result_x.aic, result_y.aic
                        newResult['bic_x'], newResult['bic_y']                   = result_x.bic, result_y.bic
                        newResult['chisqr_x'], newResult['chisqr_y']             = result_x.chisqr, result_y.chisqr
                        newResult['redchi_x'], newResult['redchi_y']             = result_x.redchi, result_y.redchi
                        newResult['residual_x'], newResult['residual_y']         = result_x.residual, result_y.residual
                        newResult['rmse_x'], newResult['rmse_y']                 = np.sqrt(np.mean([x*x for x in result_x.residual])), np.sqrt(np.mean([y*y for y in result_y.residual]))

                        newResult['classic_lat_x'], newResult['classic_lat_y']   = classic_lat_x, classic_lat_y
                        newResult['classic_max_x'], newResult['classic_max_y']   = classic_max_x, classic_max_y
                        newResult['classic_ant_x'], newResult['classic_ant_y']   = classic_ant_x, classic_ant_y
                        
                        newResult['fit_x'], newResult['fit_y'] = eq_x, eq_y

                        target_time = velocities[tg_vel[trial]]['t']*1000
                        target_vel  = velocities[tg_vel[trial]]['v']
                        

                        qCtrl = dict()
                        qCtrl['sub']            = sub
                        qCtrl['condition']      = cond
                        qCtrl['trial']          = trial

                        if newResult['rmse_x'] > 10 or newResult['rmse_y'] > 10:
                            qCtrl['keep_trial']     = np.nan
                            qCtrl['good_fit']       = 0
                            qCtrl['discard_reason'] = np.nan
                        elif manualCheck:
                            qCtrl['keep_trial']     = int(input("Keep trial? \npress (1) to keep or (0) to discard\n "))
                            while qCtrl['keep_trial'] != 0 and qCtrl['keep_trial'] != 1:
                                qCtrl['keep_trial'] = int(input("Keep trial? \npress (1) to keep or (0) to discard\n "))

                            qCtrl['good_fit']       = int(input("Good fit? \npress (1) for yes or (0) for no\n "))
                            while qCtrl['good_fit'] != 0 and qCtrl['keep_trial'] != 1:
                                qCtrl['good_fit']   = int(input("Good fit? \npress (1) for yes or (0) for no\n "))

                            qCtrl['discard_reason'] = np.nan
                        else:
                            qCtrl['keep_trial']     = np.nan
                            qCtrl['good_fit']       = np.nan
                            qCtrl['discard_reason'] = np.nan

                        if equation == 'nonlinear':
                            f = plotFig2(trial, target_time, target_vel, type_v, type_h,
                                        newResult['time_y'], newResult['velocity_y'], eq_y, newResult['aSPon_y'], newResult['aSPoff_y'],
                                        newResult['time_x'], newResult['velocity_x'], eq_x, newResult['aSPon_x'], newResult['aSPoff_x'],
                                        show=False)
                        elif equation=='sigmoid':
                            f = plotFig2(trial, target_time, target_vel, type_v, type_h,
                                        newResult['time_y'], newResult['velocity_y'], eq_y, newResult['aSPon_y'], newResult['aSPoff_y'],
                                        newResult['time_x'], newResult['velocity_x'], eq_x, newResult['aSPon_x'], newResult['aSPoff_x'],
                                        show=False)
                        elif equation=='linear':
                            f = plotFig2(trial, target_time, target_vel, type_v, type_h,
                                        newResult['time_y'], newResult['velocity_y'], eq_y, newResult['aSPon_y'], newResult['SPlat_y'],
                                        newResult['time_x'], newResult['velocity_x'], eq_x, newResult['aSPon_x'], newResult['SPlat_x'],
                                        show=False)
                        
                        if newResult['rmse_x'] < 10:
                            # print('good')
                            pdf.savefig(f)
                        else:
                            badFitspdf.savefig(f)
                            print('bad')

                        plt.close(f)

                    # save trial's fit data to a dataframe
                    paramsSub = pd.concat([paramsSub, pd.DataFrame([newResult], columns=newResult.keys())], ignore_index=True)
                    qualityCtrl = pd.concat([qualityCtrl, pd.DataFrame([qCtrl], columns=qCtrl.keys())], ignore_index=True)

            badTrialspdf.close()
            badFitspdf.close()

            pdf.close()
            plt.close('all')

            paramsSub.to_hdf(h5_file, 'data/')
            paramsRaw.to_hdf(h5_rawfile, 'raw/')
            qualityCtrl.to_hdf(h5_qcfile, 'data/')

            # test if it can read the file
            abc = pd.read_hdf(h5_file, 'data/')
            abc.head()

            del paramsRaw, abc, paramsSub, qualityCtrl, newResult

        except Exception as e:
            print('Error! \n Couldn\'t process {}, condition {}'.format(sub,cond))
            traceback.print_exc()

# %%
